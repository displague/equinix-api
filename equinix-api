#!/usr/bin/env zsh -e

# Support leading --portal flag to use portal.equinix.com with a cookie instead of OAuth
if [[ "$1" == "--portal" ]]; then
    PORTAL=1
    shift
fi

api_path="$1"
# default to GET if no method is provided
api_method="${2:-GET}"
api_data="$3"


# Usage/help output
usage() {
        cat <<EOF
Usage:
    equinix-api <api_path> [METHOD] [DATA]
    equinix-api --list <api_prefix>
    equinix-api --help

Arguments:
    <api_path>   The API path, e.g. metal/devices or fabric/v4/connections
    [METHOD]     HTTP method (default: GET)
    [DATA]       Data to send (for POST/PUT/PATCH)
    --portal     Use portal.equinix.com using a temporary portal cookie
    --list       List all available methods and paths for an API prefix (e.g. metal/v1)
    --help       Show this help message

Environment variables:
    PARSER              Parser command (defaults to first found: 'yq -y .', 'jq .', 'cat')
    METAL_AUTH_TOKEN    Auth token for /metal/ APIs (overrides config)
    EQUINIX_CLIENT_ID   OAuth client ID (overrides config)
    EQUINIX_CLIENT_SECRET OAuth client secret (overrides config)
    EQUINIX_PORTAL_COOKIE Cookie string to use when --portal is specified (overrides config)
    EQUINIX_PORTAL_COOKIE_NAME Optional cookie name to fetch via get_cookie when no cookie is present (default: BearerToken)

Config files:
    ~/.config/equinix/equinix.yaml: Contains equinix_client_id, equinix_client_secret, metal_auth_token, equinix_portal_cookie, equinix_portal_cookie_name
    ~/.config/equinix/metal.yaml: Contains token for /metal/ APIs

Examples:
    equinix-api ne/v1/metros
    equinix-api metal/v1/locations/metros
    equinix-api /fabric/v4/connections POST '{"foo": "bar"}'
    equinix-api '/colocations/v2/locations?permissionCode=WORK_VISIT'
    equinix-api --list metal/v1
    equinix-api --portal v1/users/user@example.com

EOF
}


# get_cookie <url> <cookie_name>
get_cookie() {
    local url="$1"
    local cookie_name="$2"
    local port=9222
    local tmpdir
    local browser_pid=

    # Try to find an installed Chrome/Chromium executable
    local chrome_exec=""
    for c in google-chrome google-chrome-stable chromium chromium-browser chrome; do
        if command -v "$c" >/dev/null 2>&1; then
            chrome_exec="$c"
            break
        fi
    done

    # On macOS, try opening the Google Chrome app with remote debugging if the binary isn't on PATH
    if [[ -z "$chrome_exec" && -d "/Applications/Google Chrome.app" ]]; then
        tmpdir=$(mktemp -d)
        open -a "Google Chrome" --args --remote-debugging-port=$port --user-data-dir="$tmpdir" "$url" &
        browser_pid=$!
    elif [[ -n "$chrome_exec" ]]; then
        tmpdir=$(mktemp -d)
        "$chrome_exec" --remote-debugging-port=$port --user-data-dir="$tmpdir" "$url" &
        browser_pid=$!
    else
        # Generic fallback: open the URL in the user's default browser and ask them to paste the cookie
        echo "No Chrome/Chromium executable found. Opening the URL in your default browser and asking for manual cookie input." >&2
        open "$url"
        echo
        echo "Please log in to the portal at: $url" >&2
        echo "After login, open your browser's developer tools, locate the cookie named '$cookie_name', and paste its value here:" >&2
        printf "%s" "$cookie_name value: "
        read -r cookie_value
        echo "$cookie_value"
        return 0
    fi

    echo "Browser started (pid=$browser_pid), please log in to: $url" >&2
    echo "Waiting for cookie: $cookie_name (DevTools port: $port)" >&2

    # Poll until cookie is set via DevTools HTTP endpoints (best-effort)
    local cookie_value=""
    while [ -z "$cookie_value" ]; do
        # Query list of targets then ask each for cookies via /json/version or websocket - this is a best-effort approach
        cookie_value=$(curl -s "http://localhost:$port/json" 2>/dev/null \
            | yq -r '.[].webSocketDebuggerUrl? as $w | ""' 2>/dev/null || true)
        # Try the older /json endpoint for pages and look for cookies via protocol (best-effort; may fail on some installs)
        # Try the newer Storage.getCookies first (recommended), fall back to Network.getAllCookies for older backends
        cookie_value=$(curl -s -H "Content-Type: application/json" --data '{"id":1,"method":"Storage.getCookies"}' "http://localhost:$port/json/protocol" 2>/dev/null \
            | yq -r ".result.cookies[]? | select(.name==\"$cookie_name\") | .value" 2>/dev/null || true)
        if [[ -z "$cookie_value" ]]; then
            cookie_value=$(curl -s -H "Content-Type: application/json" --data '{"id":1,"method":"Network.getAllCookies"}' "http://localhost:$port/json/protocol" 2>/dev/null \
                | yq -r ".result.cookies[]? | select(.name==\"$cookie_name\") | .value" 2>/dev/null || true)
        fi
        sleep 2
    done

    echo "Cookie [$cookie_name] acquired: $cookie_value" >&2

    # Cleanup browser if we started it
    if [[ -n "$browser_pid" ]]; then
        kill "$browser_pid" >/dev/null 2>&1 || true
    fi
    if [[ -n "$tmpdir" ]]; then
        rm -rf "$tmpdir" || true
    fi

    # Return just the value
    echo "$cookie_value"
}

# Show help if no args or --help
if [[ $# -eq 0 || "$1" == "--help" ]]; then
    usage
    exit 0
fi
    
# --list <prefix> support
if [[ "$1" == "--list" ]]; then
    if [[ -z "$2" ]]; then
        echo "Usage: equinix-api --list <api_prefix>" >&2
        exit 1
    fi
        prefix="$2"
        # Remove all slashes and join segments (e.g., metal/v1 -> metalv1)
        prefix_no_slash="${prefix##/}"
        prefix_flat=$(echo "$prefix_no_slash" | tr -d '/')
        openapi_url="https://docs.equinix.com/api-catalog/${prefix_flat}/openapi.yaml"
        if ! command -v yq &>/dev/null; then
                echo "yq is required for --list" >&2
                exit 1
        fi
        echo "Fetching OpenAPI spec from $openapi_url..." >&2
        openapi_content=$(curl -s "$openapi_url")
            # Check if the content looks like YAML (starts with openapi: or swagger:)
            if ! echo "$openapi_content" | grep -qE '^(openapi:|swagger:)' ; then
                    echo "Error: The fetched file does not appear to be a valid OpenAPI YAML document." >&2
                    echo "$openapi_content" | head -20 >&2
                    exit 2
            fi
            # Check if .paths exists and is not null
            if ! echo "$openapi_content" | yq -e '.paths' >/dev/null 2>&1; then
                    echo "Error: No .paths found in OpenAPI spec (API may not exist or is not documented)." >&2
                    exit 5
            fi
            # List methods and paths
                    echo "$openapi_content" | yq -r '
                        .paths | to_entries[] | .key as $path | .value | to_entries[]? | "\(.key) \($path)"'
            exit $?
fi

# If PARSER is supplied as an env variable, use it. Otherwise, try yq, jq, then cat.
if [[ -n "$PARSER" ]]; then
    PARSER=(${(z)PARSER})
else
    for candidate in 'yq -y .' 'jq .' 'cat'; do
        set -- ${(z)candidate}
        if command -v $1 &> /dev/null; then
            PARSER=($@)
            break
        fi
    done
fi

BASE_URL="https://api.equinix.com"
# Prepare auth headers variable (array) and base URL based on mode
AUTH_HEADERS=()

# If portal mode is enabled, resolve the portal cookie (env or config) and set Cookie header and base URL
if [[ -n "$PORTAL" ]]; then
    if [[ -n "$EQUINIX_PORTAL_COOKIE" ]]; then
        PORTAL_COOKIE="$EQUINIX_PORTAL_COOKIE"
    else
        if command -v yq &>/dev/null; then
            PORTAL_COOKIE=$(yq -r '.equinix_portal_cookie // empty' ~/.config/equinix/equinix.yaml)
            if [[ -z "$PORTAL_COOKIE" ]]; then
                # Try to acquire cookie interactively via get_cookie
                COOKIE_NAME="${EQUINIX_PORTAL_COOKIE_NAME:-}"
                if [[ -z "$COOKIE_NAME" ]]; then
                    COOKIE_NAME=$(yq -r '.equinix_portal_cookie_name // empty' ~/.config/equinix/equinix.yaml)
                fi
                COOKIE_NAME=${COOKIE_NAME:-BearerToken}
                echo "No portal cookie found in env/config; attempting to acquire cookie name '$COOKIE_NAME' via get_cookie..." >&2
                PORTAL_COOKIE=$(get_cookie "https://portal.equinix.com/" "$COOKIE_NAME")
            fi
        else
            echo "EQUINIX_PORTAL_COOKIE not set and yq not available to read ~/.config/equinix/equinix.yaml; attempting to acquire cookie via get_cookie..." >&2
            COOKIE_NAME=${EQUINIX_PORTAL_COOKIE_NAME:-BearerToken}
            PORTAL_COOKIE=$(get_cookie "https://portal.equinix.com/" "$COOKIE_NAME")
        fi
    fi

    if [[ -z "$PORTAL_COOKIE" ]]; then
        echo "Error: portal cookie not found in environment, config, or via get_cookie" >&2
        exit 1
    fi

    BASE_URL="https://portal.equinix.com/api"
    AUTH_HEADERS+=( -H "Cookie: $PORTAL_COOKIE" )
    # Some portal endpoints expect a Referer header
    AUTH_HEADERS+=( -H "Referer: https://portal.equinix.com/" )
    AUTH_HEADERS+=( -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.6 Safari/605.1.15" )
fi

# If the API path starts with /metal/, use metal_auth_token or METAL_AUTH_TOKEN, or token from metal.yaml
if [[ "$api_path" == metal/* || "$api_path" == /metal/* ]]; then
    # Resolve metal token (env first, then config files)
    if [[ -n "$METAL_AUTH_TOKEN" ]]; then
        METAL_TOKEN="$METAL_AUTH_TOKEN"
    else
        METAL_TOKEN=$(yq -r '.metal_auth_token // empty' ~/.config/equinix/equinix.yaml)
        if [[ -z "$METAL_TOKEN" ]]; then
            METAL_TOKEN=$(yq -r '.token // empty' ~/.config/equinix/metal.yaml)
        fi
    fi
    if [[ -z "$METAL_TOKEN" ]]; then
        echo "Error: metal_auth_token not found in environment, ~/.config/equinix/equinix.yaml, or ~/.config/equinix/metal.yaml" >&2
        exit 1
    fi
    AUTH_HEADERS+=( -H "X-Auth-Token: $METAL_TOKEN" )
    # metal APIs use the standard api base URL
    BASE_URL="https://api.equinix.com"
fi

# Otherwise, use OAuth2
# Allow env override for client id/secret
if [[ -n "$EQUINIX_CLIENT_ID" ]]; then
    CLIENT_ID="$EQUINIX_CLIENT_ID"
else
    CLIENT_ID=$(yq -r '.equinix_client_id' ~/.config/equinix/equinix.yaml)
fi
if [[ -n "$EQUINIX_CLIENT_SECRET" ]]; then
    CLIENT_SECRET="$EQUINIX_CLIENT_SECRET"
else
    CLIENT_SECRET=$(yq -r '.equinix_client_secret' ~/.config/equinix/equinix.yaml)
fi

if [[ ${#AUTH_HEADERS[@]} -eq 0 ]]; then
        # No auth headers set yet: perform OAuth token exchange and set Authorization header
        # Use application/x-www-form-urlencoded which the token endpoint expects
        access_token_response=$(curl -s -X POST "https://api.equinix.com/oauth2/v1/token" \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            -d "grant_type=client_credentials&client_id=${CLIENT_ID}&client_secret=${CLIENT_SECRET}")
        access_token=$(echo "$access_token_response" | jq -r '.access_token // empty')
        if [[ -z "$access_token" || "$access_token" == "null" ]]; then
            echo "Error: failed to obtain access token from https://api.equinix.com/oauth2/v1/token" >&2
            echo "Response was:" >&2
            echo "$access_token_response" >&2
            exit 1
        fi
        AUTH_HEADERS+=( -H "Authorization: Bearer $access_token" )
fi

curl --show-error --no-progress-meter -s -X "$api_method" -H "Content-type: application/json" "${(@)AUTH_HEADERS}" "$BASE_URL/${api_path}" -d "$api_data" | "${PARSER[@]}"
